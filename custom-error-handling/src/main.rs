use chrono::{DateTime, Duration, Utc};
use thiserror::Error;

/**
 * Custom Error
 * functions may fail more than one ways so usefull to communicate the failure reason
 * Error enumeration
 *
 * Error Type Requirements
 * - Implement the debug trait
 * --  display error in debug context
 * - Implement the display trait
 * -- displays error info in user context
 * - Implement the error trait
 * -- interop with code using dynamic errors
 */

/**
 * Error Handling Tips
 *
 * Prefer to use error enums over strings
 * More consisely communicate the problem
 * Can be done with match
 * Strings are fine when prototype or quick script, if the problem domain is not fully
 * understood
 * change to error enum when the problem domain is understood
 *
 * Keep error specific
 * Limit error enums to single module, single function
 * Try to use match as much as possible
 *
 * Don't put unrelated domains erros into a single enum
 * As the probelm domain expands, the enum will become unwidely
 * change to the enum will cascade across entire codebase
 * unclear which error can be generated by a function
 */

#[derive(Debug)]
struct SubwayPass {
    id: usize,
    funds: isize,
    expires: DateTime<Utc>,
}

#[derive(Debug, Error)]
enum PassError {
    #[error("Pass expired")]
    PassExpired,
    #[error("Insufficient funds: {0}")]
    InsufficientFunds(isize),
    #[error("Card read error: {0}")]
    ReadError(String),
}

fn swipe_card(funds: isize) -> Result<SubwayPass, PassError> {
    if funds < 0 {
        return Err(PassError::ReadError("Go away beggar".to_string()));
    }

    if funds > 1000 {
        return Err(PassError::ReadError(
            "Too much money go to jail".to_string(),
        ));
    }

    Ok(SubwayPass {
        id: 1,
        funds,
        expires: Utc::now() + Duration::days(30),
    })
}

fn use_pass(pass: &mut SubwayPass, cost: isize) -> Result<(), PassError> {
    if pass.expires < Utc::now() {
        return Err(PassError::PassExpired);
    }

    if pass.funds < cost {
        return Err(PassError::InsufficientFunds(cost - pass.funds));
    }

    pass.funds -= cost;
    Ok(())
}

fn main() {
    let pass_status = swipe_card(100).and_then(|mut pass| use_pass(&mut pass, 1000));

    match pass_status {
        Ok(_) => println!("Pass used successfully"),
        Err(e) => match e {
            PassError::InsufficientFunds(needed) => {
                println!("Need more money: {}", needed);
            }
            PassError::PassExpired => {
                println!("Pass expired");
            }
            PassError::ReadError(msg) => {
                println!("Card read error: {}", msg);
            }
        },
    }

    println!("{:?}", run(1));
    println!("{:?}", run(2));
}

#[derive(Debug, Error)]
enum ProgramError {
    #[error("menu error: {0}")]
    MenuError(#[from] MenuError), // from attribute to convert the error type
    #[error("math error: {0}")]
    MathError(#[from] MathError), // from attribute to convert the error type
}

#[derive(Debug, Error)]
enum MenuError {
    #[error("menu item not found")]
    NotFound,
}

#[derive(Debug, Error)]
enum MathError {
    #[error("divide by zero error")]
    DivideByZero,
}

fn pick_menu(choice: &str) -> Result<i32, MenuError> {
    match choice {
        "1" => Ok(1),
        "2" => Ok(2),
        "3" => Ok(3),
        _ => Err(MenuError::NotFound),
    }
}

fn divide(a: i32, b: i32) -> Result<i32, MathError> {
    if b != 0 {
        Ok(a / b)
    } else {
        Err(MathError::DivideByZero)
    }
}

fn run(step: i32) -> Result<(), ProgramError> {
    if step == 1 {
        pick_menu("4")?;
    } else if step == 2 {
        divide(1, 0)?;
    }
    Ok(())
}
